<!DOCTYPE html>
<html>
<head>
    <title>ë°”ë‚˜ë‚˜ íˆì–´ë¡œ - ë¬¸ì œí•´ê²° ì½”ì¹˜ì™€ í•¨ê»˜</title>
    <style>
        body { 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            background: #2c3e50;
            font-family: 'Courier New', monospace;
            color: white;
        }
        #gameContainer {
            text-align: center;
        }
        canvas { 
            border: 2px solid #3498db; 
            background: #34495e;
            border-radius: 5px;
        }
        #gameInfo {
            margin: 10px 0;
            font-size: 20px;
            color: #ecf0f1;
        }
        #instructions {
            margin: 15px 0;
            font-size: 14px;
            color: #bdc3c7;
            background: #34495e;
            padding: 10px;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        .thinking-prompt {
            background: #e74c3c;
            color: white;
            padding: 8px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
        }
        .debug-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #2ecc71;
            border: 1px solid #2ecc71;
        }
    </style>
</head>
<body>
    <div class="debug-panel" id="debugPanel">
        <div>ğŸ§  ë¬¸ì œí•´ê²° ëª¨ë“œ</div>
        <div>FPS: <span id="fps">0</span></div>
        <div>Objects: <span id="objectCount">0</span></div>
        <div>Score Rate: <span id="scoreRate">0</span></div>
    </div>

    <div id="gameContainer">
        <div class="thinking-prompt">ğŸ¤” ì–´ë–»ê²Œ í•˜ë©´ ë” ë†’ì€ ì ìˆ˜ë¥¼ ì–»ì„ ìˆ˜ ìˆì„ê¹Œ?</div>
        <div id="gameInfo">ì ìˆ˜: 0 | ìƒì¡´ ì‹œê°„: 0ì´ˆ</div>
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div id="instructions">
            â“ ì§ˆë¬¸: ì´ ê²Œì„ì˜ ëª©í‘œê°€ ë­˜ê¹Œ? ì–´ë–»ê²Œ ì´ê¸°ëŠ” ê²Œì„ì¼ê¹Œ?<br>
            âŒ¨ï¸ íŒíŠ¸: í‚¤ë³´ë“œë¡œ ë­”ê°€ í•´ë³´ì (â†â†’ ìŠ¤í˜ì´ìŠ¤ Z)
        </div>
        <div class="thinking-prompt" id="currentChallenge">
            ğŸ¯ í˜„ì¬ ë„ì „: í™”ë©´ì— ë­”ê°€ ë‚˜íƒ€ë‚˜ê²Œ ë§Œë“¤ì–´ë³´ì!
        </div>
    </div>

    <script>
        // ğŸ§  ë¬¸ì œí•´ê²° ì½”ì¹˜: ë¨¼ì € ìƒê°í•´ë³´ì!
        console.log("ğŸ¤” ìƒê°í•´ë³´ì: ê²Œì„ì„ ë§Œë“¤ë ¤ë©´ ë¬´ì—‡ì´ í•„ìš”í• ê¹Œ?");
        console.log("ğŸ’¡ íŒíŠ¸:");
        console.log("1. ë¬´ì—‡ì„ ê·¸ë¦´ê¹Œ?");
        console.log("2. ì–´ë–»ê²Œ ì›€ì§ì¼ê¹Œ?");
        console.log("3. ì–´ë–¤ ê·œì¹™ì´ ìˆì„ê¹Œ?");
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameInfo = document.getElementById('gameInfo');
        const challengeDisplay = document.getElementById('currentChallenge');
        const debugPanel = document.getElementById('debugPanel');

        // ğŸ¯ ê²Œì„ ìƒíƒœ - ì´ê²Œ ìš°ë¦¬ê°€ ì¶”ì í•´ì•¼ í•  ì •ë³´ë“¤ì´ì•¼
        let gameState = {
            score: 0,
            startTime: Date.now(),
            gameOver: false,
            challengeLevel: 1,
            lastFPS: 0,
            frameCount: 0
        };

        // ğŸ“Š í†µê³„ ì¶”ì  - ì½”ì¹˜ê°€ ì„±ê³¼ë¥¼ ë¶„ì„í•˜ê¸° ìœ„í•´
        let stats = {
            bananasThrown: 0,
            enemiesHit: 0,
            jumps: 0,
            totalDistance: 0,
            lastScoreTime: Date.now()
        };

        // ğŸµ í”Œë ˆì´ì–´ - ìš°ë¦¬ì˜ ì£¼ì¸ê³µ
        const player = {
            x: 100,
            y: 300,
            width: 40,
            height: 40,
            velocityY: 0,
            onGround: true,
            color: '#e67e22',
            lastX: 100
        };

        // ğŸŒ ë°œì‚¬ì²´ ë°°ì—´
        let projectiles = [];
        
        // ğŸ‘¾ ì ë“¤ ë°°ì—´  
        let enemies = [];

        // ğŸ® ì…ë ¥ ìƒíƒœ
        const input = {};

        // ğŸ¯ ë„ì „ ê³¼ì œ ì‹œìŠ¤í…œ - ë¬¸ì œí•´ê²° ë‹¨ê³„ë³„ ìœ ë„
        const challenges = [
            {
                id: 1,
                question: "ğŸ¯ ìºë¦­í„°ë¥¼ í™”ë©´ì—ì„œ ë³¼ ìˆ˜ ìˆë‹ˆ? ì–´ë–»ê²Œ ë³´ì´ëŠ”ì§€ ì„¤ëª…í•´ë´!",
                hint: "í™”ë©´ ì™¼ìª½ì— ì£¼í™©ìƒ‰ ë„¤ëª¨ê°€ ë³´ì´ë©´ ì„±ê³µ!",
                completed: false
            },
            {
                id: 2,
                question: "ğŸƒ ìºë¦­í„°ê°€ ì›€ì§ì´ê²Œ í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œ?",
                hint: "í™”ì‚´í‘œ í‚¤ë¥¼ ëˆŒëŸ¬ë³´ì. ë­ê°€ ì¼ì–´ë‚˜ì§€?",
                completed: false
            },
            {
                id: 3,
                question: "ğŸ¦˜ ì í”„ëŠ” í˜„ì‹¤ì—ì„œ ì–´ë–»ê²Œ ì‘ë™í•˜ì§€? ì˜¬ë¼ê°”ë‹¤ê°€ ë‚´ë ¤ì˜¤ì§€?",
                hint: "ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆŒëŸ¬ë³´ì. ì¤‘ë ¥ì´ ìˆëŠ”ì§€ í™•ì¸í•´ë´!",
                completed: false
            },
            {
                id: 4,
                question: "ğŸŒ ë¬´ê¸°ë¥¼ ë°œì‚¬í•˜ë ¤ë©´ ë­ê°€ í•„ìš”í• ê¹Œ? ìœ„ì¹˜? ë°©í–¥? ì†ë„?",
                hint: "Zí‚¤ë¥¼ ëˆ„ë¥´ë©´ ë­ê°€ ë‚˜íƒ€ë‚˜ëŠ”ì§€ ê´€ì°°í•´ë´!",
                completed: false
            },
            {
                id: 5,
                question: "ğŸ‘¾ ì ì´ ë‚˜íƒ€ë‚¬ì–´! ì´ë“¤ì„ ì–´ë–»ê²Œ ë¬¼ë¦¬ì¹  ìˆ˜ ìˆì„ê¹Œ?",
                hint: "ë°”ë‚˜ë‚˜ì™€ ì ì´ ë§Œë‚˜ë©´ ë­ê°€ ì¼ì–´ë‚ ê¹Œ?",
                completed: false
            }
        ];

        let currentChallengeIndex = 0;

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.addEventListener('keydown', (e) => {
            input[e.key] = true;
            
            // Zí‚¤ë¡œ ë°œì‚¬ì²´ ìƒì„±
            if (e.key === 'z' || e.key === 'Z') {
                createProjectile();
            }
            
            // Rí‚¤ë¡œ ì¬ì‹œì‘
            if ((e.key === 'r' || e.key === 'R') && gameState.gameOver) {
                resetGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            input[e.key] = false;
        });

        // ğŸŒ ë°œì‚¬ì²´ ìƒì„± í•¨ìˆ˜
        function createProjectile() {
            projectiles.push({
                x: player.x + player.width,
                y: player.y + player.height / 2,
                width: 15,
                height: 8,
                velocityX: 12,
                color: '#f1c40f'
            });
            
            stats.bananasThrown++;
            console.log(`ğŸ¤” ìƒê°í•´ë³´ì: ë°”ë‚˜ë‚˜ê°€ ${stats.bananasThrown}ê°œì§¸ ë°œì‚¬ëì–´. ì´ ì†ë„ë©´ ì–¼ë§ˆë‚˜ ë©€ë¦¬ ê°ˆê¹Œ?`);
            
            // ì²« ë°œì‚¬ì²´ ë„ì „ ì™„ë£Œ
            if (!challenges[3].completed) {
                challenges[3].completed = true;
                updateCurrentChallenge();
            }
        }

        // ğŸ‘¾ ì  ìƒì„± í•¨ìˆ˜
        function spawnEnemy() {
            enemies.push({
                x: canvas.width,
                y: 300,
                width: 35,
                height: 45,
                velocityX: -2 - Math.random() * 3,
                color: '#c0392b',
                health: 1
            });
        }

        // ğŸ¯ ë„ì „ ê³¼ì œ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateCurrentChallenge() {
            if (currentChallengeIndex < challenges.length && 
                challenges[currentChallengeIndex].completed) {
                currentChallengeIndex++;
            }
            
            if (currentChallengeIndex < challenges.length) {
                const challenge = challenges[currentChallengeIndex];
                challengeDisplay.textContent = challenge.question;
                console.log(`ğŸ§  ìƒˆë¡œìš´ ë„ì „: ${challenge.question}`);
                console.log(`ğŸ’¡ íŒíŠ¸: ${challenge.hint}`);
            } else {
                challengeDisplay.textContent = "ğŸ† ëª¨ë“  ë„ì „ì„ ì™„ë£Œí–ˆì–´! ì´ì œ ì–´ë–»ê²Œ ë” ì¬ë°Œê²Œ ë§Œë“¤ ìˆ˜ ìˆì„ê¹Œ?";
            }
        }

        // ğŸ¯ ê²Œì„ ë¡œì§ ì—…ë°ì´íŠ¸
        function update() {
            if (gameState.gameOver) return;

            gameState.frameCount++;
            
            // í”Œë ˆì´ì–´ ì´ë™ ì²˜ë¦¬
            const prevX = player.x;
            
            if (input['ArrowLeft'] && player.x > 0) {
                player.x -= 5;
                stats.totalDistance += Math.abs(player.x - prevX);
                
                // ì²« ì´ë™ ë„ì „ ì™„ë£Œ ì²´í¬
                if (!challenges[1].completed) {
                    challenges[1].completed = true;
                    updateCurrentChallenge();
                    console.log("ğŸ‰ ì˜í–ˆì–´! ìºë¦­í„°ê°€ ì›€ì§ì˜€ë„¤! ì´ì œ ë‹¤ë¥¸ ë°©í–¥ë„ í•´ë³¼ê¹Œ?");
                }
            }
            
            if (input['ArrowRight'] && player.x < canvas.width - player.width) {
                player.x += 5;
                stats.totalDistance += Math.abs(player.x - prevX);
                
                if (!challenges[1].completed) {
                    challenges[1].completed = true;
                    updateCurrentChallenge();
                }
            }

            // ì í”„ ì²˜ë¦¬
            if (input[' '] && player.onGround) {
                player.velocityY = -15;
                player.onGround = false;
                stats.jumps++;
                
                console.log(`ğŸ¤” í¥ë¯¸ë¡œì›Œ! ${stats.jumps}ë²ˆì§¸ ì í”„ì•¼. ì–¼ë§ˆë‚˜ ë†’ì´ ì˜¬ë¼ê°ˆê¹Œ?`);
                
                if (!challenges[2].completed) {
                    challenges[2].completed = true;
                    updateCurrentChallenge();
                    console.log("ğŸ‰ ì í”„ ì„±ê³µ! ì¤‘ë ¥ì´ ì–´ë–»ê²Œ ì‘ìš©í•˜ëŠ”ì§€ ê´€ì°°í•´ë´!");
                }
            }

            // ì¤‘ë ¥ê³¼ ë¬¼ë¦¬
            player.velocityY += 0.8;
            player.y += player.velocityY;

            // ë°”ë‹¥ ì¶©ëŒ
            if (player.y > 300) {
                player.y = 300;
                player.velocityY = 0;
                player.onGround = true;
            }

            // ë°œì‚¬ì²´ ì—…ë°ì´íŠ¸
            projectiles.forEach((proj, index) => {
                proj.x += proj.velocityX;
                if (proj.x > canvas.width) {
                    projectiles.splice(index, 1);
                }
            });

            // ì  ìƒì„± (5ì´ˆë§ˆë‹¤)
            if (gameState.frameCount % 300 === 0) {
                spawnEnemy();
                if (!challenges[4].completed) {
                    console.log("ğŸ¤” ì ì´ ë‚˜íƒ€ë‚¬ì–´! ì´ê±¸ ì–´ë–»ê²Œ ì²˜ë¦¬í• ê¹Œ?");
                }
            }

            // ì  ì´ë™
            enemies.forEach((enemy, index) => {
                enemy.x += enemy.velocityX;
                if (enemy.x < -enemy.width) {
                    enemies.splice(index, 1);
                }
            });

            // ì¶©ëŒ ê²€ì‚¬
            checkCollisions();
            
            // í†µê³„ ì—…ë°ì´íŠ¸
            updateStats();
            
            // ìºë¦­í„° ì²« í‘œì‹œ ë„ì „ ì™„ë£Œ ì²´í¬
            if (!challenges[0].completed) {
                challenges[0].completed = true;
                updateCurrentChallenge();
                console.log("ğŸ‰ í›Œë¥­í•´! ìºë¦­í„°ê°€ í™”ë©´ì— ë‚˜íƒ€ë‚¬ì–´!");
            }
        }

        // ğŸ’¥ ì¶©ëŒ ê²€ì‚¬
        function checkCollisions() {
            // ë°œì‚¬ì²´ì™€ ì  ì¶©ëŒ
            projectiles.forEach((proj, pIndex) => {
                enemies.forEach((enemy, eIndex) => {
                    if (proj.x < enemy.x + enemy.width &&
                        proj.x + proj.width > enemy.x &&
                        proj.y < enemy.y + enemy.height &&
                        proj.y + proj.height > enemy.y) {
                        
                        // ì¶©ëŒ ë°œìƒ!
                        projectiles.splice(pIndex, 1);
                        enemies.splice(eIndex, 1);
                        gameState.score += 10;
                        stats.enemiesHit++;
                        stats.lastScoreTime = Date.now();
                        
                        console.log(`ğŸ¯ ëª…ì¤‘! ${stats.enemiesHit}ë²ˆì§¸ ì ì„ ë¬¼ë¦¬ì³¤ì–´!`);
                        console.log(`ğŸ¤” ìƒê°í•´ë´: ëª…ì¤‘ë¥ ì´ ${(stats.enemiesHit/stats.bananasThrown*100).toFixed(1)}%ì•¼. ì–´ë–»ê²Œ ë” ì •í™•í•˜ê²Œ í•  ìˆ˜ ìˆì„ê¹Œ?`);
                        
                        if (!challenges[4].completed) {
                            challenges[4].completed = true;
                            updateCurrentChallenge();
                            console.log("ğŸ‰ ì™„ë²½í•´! ë°œì‚¬ì²´ì™€ ì ì˜ ì¶©ëŒì„ êµ¬í˜„í–ˆì–´!");
                        }
                    }
                });
            });

            // í”Œë ˆì´ì–´ì™€ ì  ì¶©ëŒ
            enemies.forEach(enemy => {
                if (player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y) {
                    gameState.gameOver = true;
                    console.log("ğŸ’­ ê²Œì„ì´ ëë‚¬ì–´. ì™œ ëë‚¬ì„ê¹Œ? ì–´ë–»ê²Œ ë” ì˜¤ë˜ ìƒì¡´í•  ìˆ˜ ìˆì„ê¹Œ?");
                }
            });
        }

        // ğŸ“Š í†µê³„ ì—…ë°ì´íŠ¸
        function updateStats() {
            const currentTime = Date.now();
            const survivalTime = Math.floor((currentTime - gameState.startTime) / 1000);
            
            gameInfo.textContent = `ì ìˆ˜: ${gameState.score} | ìƒì¡´: ${survivalTime}ì´ˆ | ëª…ì¤‘ë¥ : ${stats.bananasThrown > 0 ? (stats.enemiesHit/stats.bananasThrown*100).toFixed(1) : 0}%`;
            
            // FPS ê³„ì‚°
            if (gameState.frameCount % 60 === 0) {
                gameState.lastFPS = Math.round(60000 / (Date.now() - gameState.fpsTime));
                gameState.fpsTime = Date.now();
            }
            
            // ë””ë²„ê·¸ íŒ¨ë„ ì—…ë°ì´íŠ¸
            document.getElementById('fps').textContent = gameState.lastFPS || 60;
            document.getElementById('objectCount').textContent = projectiles.length + enemies.length + 1;
            document.getElementById('scoreRate').textContent = (gameState.score / survivalTime * 60 || 0).toFixed(1) + '/min';
        }

        // ğŸ¨ ë Œë”ë§
        function draw() {
            // í™”ë©´ ì§€ìš°ê¸°
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ê²©ì ë°°ê²½ (ë””ë²„ê¹…ìš©)
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // ë°”ë‹¥
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(0, 340, canvas.width, 60);

            // í”Œë ˆì´ì–´
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            
            // í”Œë ˆì´ì–´ ì–¼êµ´
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(player.x + 8, player.y + 8, 6, 6);
            ctx.fillRect(player.x + 20, player.y + 8, 6, 6);
            ctx.fillRect(player.x + 10, player.y + 20, 15, 4);

            // ë°œì‚¬ì²´ë“¤
            ctx.fillStyle = '#f1c40f';
            projectiles.forEach(proj => {
                ctx.fillRect(proj.x, proj.y, proj.width, proj.height);
                
                // ë°œì‚¬ì²´ ê¶¤ì  (ì‹œê°ì  ë””ë²„ê¹…)
                ctx.strokeStyle = 'rgba(241, 196, 15, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(proj.x, proj.y + proj.height/2);
                ctx.lineTo(proj.x - 20, proj.y + proj.height/2);
                ctx.stroke();
            });

            // ì ë“¤
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                
                // ì  ì–¼êµ´
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(enemy.x + 5, enemy.y + 8, 4, 4);
                ctx.fillRect(enemy.x + 15, enemy.y + 8, 4, 4);
                
                // ì´ë™ ë°©í–¥ í‘œì‹œ (ë””ë²„ê¹…)
                ctx.strokeStyle = 'rgba(192, 57, 43, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(enemy.x, enemy.y + enemy.height/2);
                ctx.lineTo(enemy.x - 30, enemy.y + enemy.height/2);
                ctx.stroke();
            });

            // ê²Œì„ ì˜¤ë²„ í™”ë©´
            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ecf0f1';
                ctx.font = '36px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('ê²Œì„ ë¶„ì„ ì™„ë£Œ', canvas.width/2, canvas.height/2 - 60);
                
                ctx.font = '18px Courier New';
                ctx.fillText(`ìµœì¢… ì ìˆ˜: ${gameState.score}`, canvas.width/2, canvas.height/2 - 20);
                ctx.fillText(`ìƒì¡´ ì‹œê°„: ${Math.floor((Date.now() - gameState.startTime)/1000)}ì´ˆ`, canvas.width/2, canvas.height/2);
                ctx.fillText(`ëª…ì¤‘ë¥ : ${stats.bananasThrown > 0 ? (stats.enemiesHit/stats.bananasThrown*100).toFixed(1) : 0}%`, canvas.width/2, canvas.height/2 + 20);
                
                ctx.font = '14px Courier New';
                ctx.fillStyle = '#3498db';
                ctx.fillText('ğŸ¤” ì–´ë–»ê²Œ ë” ì¢‹ì€ ì„±ê³¼ë¥¼ ë‚¼ ìˆ˜ ìˆì„ê¹Œ?', canvas.width/2, canvas.height/2 + 50);
                ctx.fillText('Rí‚¤ë¥¼ ëˆŒëŸ¬ ë‹¤ì‹œ ë¶„ì„í•´ë³´ì!', canvas.width/2, canvas.height/2 + 70);
                
                ctx.textAlign = 'left';
            }
        }

        // ğŸ”„ ê²Œì„ ë¦¬ì…‹
        function resetGame() {
            gameState = {
                score: 0,
                startTime: Date.now(),
                gameOver: false,
                challengeLevel: 1,
                lastFPS: 0,
                frameCount: 0,
                fpsTime: Date.now()
            };
            
            stats = {
                bananasThrown: 0,
                enemiesHit: 0,
                jumps: 0,
                totalDistance: 0,
                lastScoreTime: Date.now()
            };
            
            player.x = 100;
            player.y = 300;
            player.velocityY = 0;
            player.onGround = true;
            
            projectiles = [];
            enemies = [];
            
            // ë„ì „ ê³¼ì œ ë¦¬ì…‹
            challenges.forEach(challenge => challenge.completed = false);
            currentChallengeIndex = 0;
            updateCurrentChallenge();
            
            console.log("ğŸ”„ ìƒˆë¡œìš´ ë¶„ì„ ì‹œì‘! ì´ë²ˆì—ëŠ” ì–´ë–¤ ì „ëµì„ ì¨ë³¼ê¹Œ?");
        }

        // ğŸ® ê²Œì„ ë£¨í”„
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // ğŸš€ ê²Œì„ ì‹œì‘
        console.log("ğŸ§  ë¬¸ì œí•´ê²° ì½”ì¹˜ì™€ í•¨ê»˜í•˜ëŠ” ë°”ë‚˜ë‚˜ íˆì–´ë¡œ!");
        console.log("ğŸ¯ ëª©í‘œ: ìŠ¤ìŠ¤ë¡œ ìƒê°í•˜ê³  ë°œê²¬í•˜ë©° ê²Œì„ì„ ì´í•´í•˜ê¸°");
        console.log("ğŸ¤” ì²« ë²ˆì§¸ ì§ˆë¬¸: í™”ë©´ì— ë­ê°€ ë³´ì´ë‹ˆ?");
        
        gameState.fpsTime = Date.now();
        updateCurrentChallenge();
        gameLoop();
    </script>
</body>
</html>